<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Orange Sun - ci</title><link href="https://potyarkin.com/" rel="alternate"></link><link href="https://potyarkin.com/feeds/ci.atom.xml" rel="self"></link><id>https://potyarkin.com/</id><updated>2022-03-02T00:00:00+03:00</updated><subtitle>Unsorted ramblings, sometimes related to programming</subtitle><entry><title>Unexpected workaround for Libvirt VMs with cgroups v2 in Cirrus CI</title><link href="https://potyarkin.com/posts/2022/libvirt-cirrusci-workaround/" rel="alternate"></link><published>2022-03-02T00:00:00+03:00</published><updated>2022-03-02T00:00:00+03:00</updated><author><name>Vitaly Potyarkin</name></author><id>tag:potyarkin.com,2022-03-02:/posts/2022/libvirt-cirrusci-workaround/</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;Today I wrote a &lt;a href="https://gitlab.com/sio/server_common/-/commit/5777cfae5446e7056fd95408c10e5273cd6529fd"&gt;commit message&lt;/a&gt; that was several screens long.
I think it deserves to be a blog post of its own&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Update:&lt;/em&gt; the commit linked above required some &lt;a href="https://gitlab.com/sio/server_common/-/commit/ebde5a880fc648be382a157454bc1ab17a8e0cd5"&gt;modification&lt;/a&gt; to remove
flakiness, but the workaround still stands. Diff provided in this blog post
was updated to reflect current â€¦&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;Today I wrote a &lt;a href="https://gitlab.com/sio/server_common/-/commit/5777cfae5446e7056fd95408c10e5273cd6529fd"&gt;commit message&lt;/a&gt; that was several screens long.
I think it deserves to be a blog post of its own&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Update:&lt;/em&gt; the commit linked above required some &lt;a href="https://gitlab.com/sio/server_common/-/commit/ebde5a880fc648be382a157454bc1ab17a8e0cd5"&gt;modification&lt;/a&gt; to remove
flakiness, but the workaround still stands. Diff provided in this blog post
was updated to reflect current state of affairs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Recently Cirrus CI builds that were using nested Libvirt VMs have started
failing with the following error:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Call to virDomainCreateWithFlags failed: unable to open
&amp;#39;/sys/fs/cgroup/machine/qemu-2-defaultdebian11-server.libvirt-qemu/&amp;#39;:
No such file or directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;First recorded failure occured on
&lt;a href="https://cirrus-ci.com/task/5115427394158592"&gt;February 25th, 2022&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Error message clearly indicates that the issue is related to Linux control
groups (cgroups), and on a hunch I assumed that Cirrus CI (or Google Cloud)
images were updated to use cgroups v2 by default. Unfortunately I haven't
been recording debug information for cgroups before the failure, so I can
not confirm my guess. Currently cgroups2 are in use, so the hypothesis stands.&lt;/p&gt;
&lt;p&gt;Web search has led me to several useful pages:&lt;/p&gt;
&lt;h4 id="redhat-bugzilla"&gt;&lt;a class="toclink" href="#redhat-bugzilla"&gt;&lt;a href="https://bugzilla.redhat.com/show_bug.cgi?id=1985377#c1"&gt;RedHat bugzilla&lt;/a&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Running Libvirt from inside a container (similar to how Cirrus does) produced
the same error.  The reason is that default cgroups mode was changed in podman
when upgrading from cgroups v1 (host mode) to v2 (private mode).&lt;/p&gt;
&lt;p&gt;I took note of this issue, but I moved on with my research since as a user
I can not change the configuration of container runtime at Cirrus CI.&lt;/p&gt;
&lt;h4 id="libvirt-documentation"&gt;&lt;a class="toclink" href="#libvirt-documentation"&gt;&lt;a href="https://libvirt.org/cgroups.html"&gt;Libvirt documentation&lt;/a&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Libvirt will not auto-create the cgroups directory to back this
partition. In the future, libvirt / virsh will provide APIs / commands
to create custom partitions, but currently this is left as an exercise
for the administrator.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Based on the documentation quoted above I have tried to manually create
the required cgroup with a simple &lt;code&gt;mkdir -p $CGROUP&lt;/code&gt;. Please note that
Libvirt uses different cgroup layouts when running on systems with and
without systemd. Cirrus CI runners use a different (non-systemd) init in
their containers, so the cgroup path in our case is
&lt;code&gt;$MOUNTPOINT/machine/qemu-$ID-$MACHINENAME.libvirt-qemu/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Manual creation of cgroup did not lead to any changes in Libvirt behavior.
Error message stayed the same: no such file or directory.&lt;/p&gt;
&lt;p&gt;Report author at &lt;a href="https://bugzilla.redhat.com/show_bug.cgi?id=1985377#c1"&gt;RedHat bugzilla&lt;/a&gt; had mentioned that they had trouble
with manually moving QEMU process into a different cgroup, so I've tried to do
that and see if the error message will provide any further information.&lt;/p&gt;
&lt;p&gt;I configured Cirrus CI to create a long-running background process and to
migrate it to the newly created cgroup. I was expecting this to fail, so I
did not comment out the code that later would launch a Libvirt VM on CI
runner. &lt;em&gt;Imagine my surprise when the pipeline turned green!&lt;/em&gt; Not only did
the migration succeed, but its success had somehow lead to the success of
Libvirt VM!&lt;/p&gt;
&lt;p&gt;A few trial runs later I noticed that the name of cgroup used in the first
step does not even have to match the cgroup (or cgroups) that will be used
by Libvirt domains.&lt;/p&gt;
&lt;p&gt;This is why I'm adding this meaningless cgroups burn-in to my pipelines.
"It ain't stupid if it works", right?&lt;/p&gt;
&lt;h4 id="full-commit-diff"&gt;&lt;a class="toclink" href="#full-commit-diff"&gt;Full commit diff&lt;/a&gt;&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="gh"&gt;diff --git a/.cirrus.yml.j2 b/.cirrus.yml.j2&lt;/span&gt;
&lt;span class="gd"&gt;--- a/.cirrus.yml.j2&lt;/span&gt;
&lt;span class="gi"&gt;+++ b/.cirrus.yml.j2&lt;/span&gt;
&lt;span class="gu"&gt;@@ -21,6 +21,8 @@ task:&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;    # VENVDIR must be absolute path for &amp;#39;cd &amp;amp;&amp;amp; make&amp;#39; approach to work
&lt;span class="w"&gt; &lt;/span&gt;    # VENVDIR should not be cached! Cirrus CI drops some binaries randomly

&lt;span class="gi"&gt;+    CGROUP_WORKAROUND: /sys/fs/cgroup/machine/qemu-cgroup_workaround.libvirt-qemu&lt;/span&gt;
&lt;span class="gi"&gt;+&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;    # Pass values from cirrus-run environment
&lt;span class="w"&gt; &lt;/span&gt;    CLONE_URL: &amp;quot;{{ CI_REPOSITORY_URL }}&amp;quot;
&lt;span class="w"&gt; &lt;/span&gt;    CLONE_SHA: &amp;quot;{{ CI_COMMIT_SHA }}&amp;quot;
&lt;span class="gu"&gt;@@ -61,6 +63,16 @@ task:&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;  libvirtd_background_script:
&lt;span class="w"&gt; &lt;/span&gt;    - sleep 2 &amp;amp;&amp;amp; /usr/sbin/libvirtd

&lt;span class="gi"&gt;+  # Workaround for cgroups v2&lt;/span&gt;
&lt;span class="gi"&gt;+  # I have no idea why or how this works (see commit message for a longer rant)&lt;/span&gt;
&lt;span class="gi"&gt;+  cgroups_workaround_background_script:&lt;/span&gt;
&lt;span class="gi"&gt;+    - mkdir -p &amp;quot;$CGROUP_WORKAROUND&amp;quot;&lt;/span&gt;
&lt;span class="gi"&gt;+    - ls -lF &amp;quot;$CGROUP_WORKAROUND&amp;quot;&lt;/span&gt;
&lt;span class="gi"&gt;+    - bash -c &amp;#39;echo $$ &amp;gt; /tmp/cgroups_workaround.pid; sleep infinity&amp;#39; &amp;amp;&lt;/span&gt;
&lt;span class="gi"&gt;+    - sleep 1&lt;/span&gt;
&lt;span class="gi"&gt;+    - cat /tmp/cgroups_workaround.pid &amp;gt;&amp;gt; $CGROUP_WORKAROUND/cgroup.procs&lt;/span&gt;
&lt;span class="gi"&gt;+    - cat $CGROUP_WORKAROUND/cgroup.procs&lt;/span&gt;
&lt;span class="gi"&gt;+&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;  # Execute automated tests
&lt;span class="w"&gt; &lt;/span&gt;  test_script:
&lt;span class="w"&gt; &lt;/span&gt;    - cd ansible/tests
&lt;span class="gu"&gt;@@ -70,6 +82,9 @@ task:&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;  always:
&lt;span class="w"&gt; &lt;/span&gt;    cache_debug_script:
&lt;span class="w"&gt; &lt;/span&gt;      - find &amp;quot;$HOME/cache&amp;quot; -type f || echo &amp;quot;Exit code: $?&amp;quot;
&lt;span class="gi"&gt;+    cgroups_debug_script:&lt;/span&gt;
&lt;span class="gi"&gt;+      - fgrep cgroup /proc/mounts || echo &amp;quot;Exit code: $?&amp;quot;&lt;/span&gt;
&lt;span class="gi"&gt;+      - find /sys/fs/cgroup -exec ls -ldF {} \; || echo &amp;quot;Exit code: $?&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;    kvm_debug_script:
&lt;span class="w"&gt; &lt;/span&gt;      - free -h
&lt;span class="w"&gt; &lt;/span&gt;      - pstree -alT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="posts"></category><category term="ci"></category><category term="automation"></category><category term="libvirt"></category></entry><entry><title>Running Libvirt (KVM) in Cirrus CI</title><link href="https://potyarkin.com/posts/2020/running-libvirt-kvm-in-cirrus-ci/" rel="alternate"></link><published>2020-02-25T00:00:00+03:00</published><updated>2020-02-25T00:00:00+03:00</updated><author><name>Vitaly Potyarkin</name></author><id>tag:potyarkin.com,2020-02-25:/posts/2020/running-libvirt-kvm-in-cirrus-ci/</id><summary type="html">&lt;p&gt;Up until the middle of 2019 it was very unusual to even expect that any CI
service would allow nested virtualization. Those who required such
functionality had to maintain their own CI runners on their own
infrastructure. Things changed when Google Cloud introduced &lt;a href="https://cloud.google.com/compute/docs/instances/enable-nested-virtualization-vm-instances"&gt;nested
KVM&lt;/a&gt; support.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cirrus-ci.org/"&gt;Cirrus CI&lt;/a&gt; was probably â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;Up until the middle of 2019 it was very unusual to even expect that any CI
service would allow nested virtualization. Those who required such
functionality had to maintain their own CI runners on their own
infrastructure. Things changed when Google Cloud introduced &lt;a href="https://cloud.google.com/compute/docs/instances/enable-nested-virtualization-vm-instances"&gt;nested
KVM&lt;/a&gt; support.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cirrus-ci.org/"&gt;Cirrus CI&lt;/a&gt; was probably the first CI service to &lt;a href="https://cirrus-ci.org/guide/linux/#kvm-enabled-privileged-containers"&gt;officially
support&lt;/a&gt; nested virtualization in free tier. There are reports
that Travis CI currently also provides such feature but no public announcement
has been made yet.&lt;/p&gt;
&lt;p&gt;It turns out I was the first person to try using Libvirt in Cirrus CI (I've
even hit a previously unknown &lt;a href="https://github.com/cirruslabs/cirrus-ci-docs/issues/564"&gt;bug&lt;/a&gt; which was promptly fixed by their staff).
Since the process has some subtle differences to the popular documented use
cases I've decided to describe it here.&lt;/p&gt;
&lt;h2 id="hypervisor-environment"&gt;&lt;a class="toclink" href="#hypervisor-environment"&gt;Hypervisor environment&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Cirrus CI uses Docker images as environment for their runners. It
significantly simplifies the setup and enables efficient caching between runs.&lt;/p&gt;
&lt;p&gt;Since popular Docker images do not include any hypervisor packages we need to
build our own image. I've decided to add the required packages to Debian base
image. The whole &lt;a href="https://gitlab.com/sio/server_common/-/blob/master/ansible/tests/Dockerfile.host-kvm"&gt;Dockerfile&lt;/a&gt; is essentially one &lt;code&gt;apt-get&lt;/code&gt; statement.&lt;/p&gt;
&lt;p&gt;Keep in mind that libvirt package in Debian drops root privileges when
launching &lt;code&gt;qemu-kvm&lt;/code&gt;. You'll either need to disable that in
&lt;code&gt;/etc/libvirt/qemu.conf&lt;/code&gt; (as I did) or to change permissions for &lt;code&gt;/dev/kvm&lt;/code&gt; to
allow access by &lt;code&gt;libvirt-qemu&lt;/code&gt; user.&lt;/p&gt;
&lt;h2 id="required-system-services"&gt;&lt;a class="toclink" href="#required-system-services"&gt;Required system services&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Default entry point for CI runner is not customizable in Cirrus CI - it's an
agent process that communicates with CI service and sends progress reports you
see in web interface. Because of that no systemd units are started automatically
as it would have been the case on a normal system. More than that, starting
systemd manually also looks impossible.&lt;/p&gt;
&lt;p&gt;That means all the daemons required by libvirt must be started manually (see
documentation on &lt;a href="https://cirrus-ci.org/guide/writing-tasks/#background-script-instruction"&gt;background_script&lt;/a&gt; syntax):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# .cirrus.yml&lt;/span&gt;
&lt;span class="nt"&gt;dbus_background_script&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;mkdir -p /var/run/dbus&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;/usr/bin/dbus-daemon --system --nofork --nopidfile&lt;/span&gt;
&lt;span class="nt"&gt;virtlogd_background_script&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;/usr/sbin/virtlogd&lt;/span&gt;
&lt;span class="nt"&gt;libvirtd_background_script&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;sleep 2 &amp;amp;&amp;amp; /usr/sbin/libvirtd&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="firewall-configuration"&gt;&lt;a class="toclink" href="#firewall-configuration"&gt;Firewall configuration&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Hypervisor kernel is provided as is, and it currently runs legacy iptables
firewall. Trying to use iptables-nft (which is the default in current Debian)
produces a misconfigured guest network that is hard to debug.&lt;/p&gt;
&lt;p&gt;That's why we need to tell Debian to use legacy iptables interface across the whole
system:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# .cirrus.yml&lt;/span&gt;
&lt;span class="nt"&gt;iptables_legacy_script&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;update-alternatives --set iptables /usr/sbin/iptables-legacy&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="_1"&gt;&lt;a class="toclink" href="#_1"&gt;&amp;nbsp;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;That's it! Following these steps I was able to execute Libvirt (via
Vagrant-Libvirt, via Molecule) in Cirrus CI environment. &lt;a href="https://gitlab.com/sio/server_common/-/blob/master/.cirrus.yml.j2"&gt;Full configuration&lt;/a&gt;
is available here, it includes some extra caching steps and many debug
statements that helped me to implement this process in the first place.&lt;/p&gt;</content><category term="posts"></category><category term="ci"></category><category term="automation"></category></entry><entry><title>Cirrus CI integration for GitLab projects</title><link href="https://potyarkin.com/posts/2020/cirrus-ci-integration-for-gitlab-projects/" rel="alternate"></link><published>2020-02-18T00:00:00+03:00</published><updated>2020-02-18T00:00:00+03:00</updated><author><name>Vitaly Potyarkin</name></author><id>tag:potyarkin.com,2020-02-18:/posts/2020/cirrus-ci-integration-for-gitlab-projects/</id><summary type="html">&lt;p&gt;&lt;a href="https://cirrus-ci.org/"&gt;Cirrus CI&lt;/a&gt; is a relatively new hosted CI service that offers several unique
features. It's probably the only CI provider to offer full virtualization
(KVM) or FreeBSD runners for free. Currently their business model is centered
around GitHub Marketplace and only the projects hosted at GitHub are
supported.&lt;/p&gt;
&lt;p&gt;Fortunately Cirrus â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://cirrus-ci.org/"&gt;Cirrus CI&lt;/a&gt; is a relatively new hosted CI service that offers several unique
features. It's probably the only CI provider to offer full virtualization
(KVM) or FreeBSD runners for free. Currently their business model is centered
around GitHub Marketplace and only the projects hosted at GitHub are
supported.&lt;/p&gt;
&lt;p&gt;Fortunately Cirrus CI provides a very capable GraphQL &lt;a href="https://cirrus-ci.org/api/"&gt;API&lt;/a&gt;. Thanks to that I
was able to write a simple command line tool to trigger CI builds with custom
configuration: &lt;a href="https://github.com/sio/cirrus-run"&gt;cirrus-run&lt;/a&gt;. It reads a local YAML file and executes Cirrus
CI build with that configuration. You can execute the build against any
GitHub repo you're allowed to access.&lt;/p&gt;
&lt;p&gt;Since build configuration is not provided by the repo the job may have no
relation to it. You can execute any number of jobs for any number of projects
against a single dummy holding repo at GitHub - which is the approach I
suggest to use for setting up integration with other source code hosting
platforms.&lt;/p&gt;
&lt;p&gt;Here is how I've set it up with GitLab:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Project repo is hosted at GitLab&lt;/li&gt;
&lt;li&gt;Each push triggers a &lt;a href="https://gitlab.com/sio/server_common/-/jobs/441624574"&gt;new build&lt;/a&gt; in GitLab CI.
    The only purpose of that build is to execute &lt;code&gt;cirrus-run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/sio/cirrus-run"&gt;cirrus-run&lt;/a&gt; triggers the &lt;a href="https://cirrus-ci.com/task/5420732842770432"&gt;real build&lt;/a&gt; in Cirrus CI, waits for it to
    complete and reports the results.&lt;/p&gt;
&lt;p&gt;Cirrus CI build is owned by a dummy GitHub repo that contains only one
initial commit. Providing &lt;a href="https://cirrus-ci.org/guide/tips-and-tricks/#custom-clone-command"&gt;custom clone script&lt;/a&gt; allows to skip cloning
that dummy repo.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That allows me to continue using GitLab to host my project and GitLab CI to
run the jobs it's good at while delegating the more demanding jobs to Cirrus
CI. All status reports are gathered by GitLab CI and failure notifications
arrive uniformly to my inbox regardless of where the build was executed.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://gitlab.com/sio/server_common/pipelines/118955114"&gt;&lt;img alt="Cirrus jobs in GitLab CI" src="https://potyarkin.com/posts/2020/cirrus-ci-integration-for-gitlab-projects/cirrus-gitlab.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Configuration files that enable the workflow described above:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://gitlab.com/sio/server_common/-/blob/795a204b90ddfd95e36d2753d9c7ea6d3a9f6573/.gitlab-ci.yml#L46-55"&gt;GitLab CI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://gitlab.com/sio/server_common/-/blob/795a204b90ddfd95e36d2753d9c7ea6d3a9f6573/.cirrus.yml.j2"&gt;Cirrus CI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="posts"></category><category term="automation"></category><category term="ci"></category></entry><entry><title>Cygwin CI journey</title><link href="https://potyarkin.com/posts/2020/cygwin-ci-journey/" rel="alternate"></link><published>2020-01-28T00:00:00+03:00</published><updated>2020-01-28T00:00:00+03:00</updated><author><name>Vitaly Potyarkin</name></author><id>tag:potyarkin.com,2020-01-28:/posts/2020/cygwin-ci-journey/</id><summary type="html">&lt;p&gt;Setting up Cygwin CI environment for testing one of my projects took more
than fifty trial-and-error attempts - that's why I think it will be useful to
leave some written notes on the issues I've encountered. Here is the end
&lt;a href="https://github.com/sio/Makefile.venv/blob/master/.github/workflows/test.yml"&gt;result&lt;/a&gt; - GitHub CI running some Makefile tests in Cygwin.&lt;/p&gt;
&lt;h2 id="cygwin-gotchas"&gt;&lt;a class="toclink" href="#cygwin-gotchas"&gt;Cygwin gotchas â€¦&lt;/a&gt;&lt;/h2&gt;</summary><content type="html">&lt;p&gt;Setting up Cygwin CI environment for testing one of my projects took more
than fifty trial-and-error attempts - that's why I think it will be useful to
leave some written notes on the issues I've encountered. Here is the end
&lt;a href="https://github.com/sio/Makefile.venv/blob/master/.github/workflows/test.yml"&gt;result&lt;/a&gt; - GitHub CI running some Makefile tests in Cygwin.&lt;/p&gt;
&lt;h2 id="cygwin-gotchas"&gt;&lt;a class="toclink" href="#cygwin-gotchas"&gt;Cygwin gotchas&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Cygwin installer likes to fail silently, providing only cryptic exit codes
    (&lt;code&gt;127&lt;/code&gt; or &lt;code&gt;-1073741571&lt;/code&gt;)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;%CYGWIN_ROOT%\setup.exe --quiet-mode --verbose --no-desktop --download --local-install --no-verify --site %CYGWIN_MIRROR% --local-package-dir %CYGWIN_PACKAGE_CACHE% --root %CYGWIN_ROOT%
Starting cygwin install, version 2.897
User has backup/restore rights
io_stream_cygfile: fopen(/etc/setup/setup.rc) failed 2 No such file or directory
Current Directory: cache\cygwin-packages
Could not open service McShield for query, start and stop. McAfee may not be installed, or we don&amp;#39;t have access.
root: d:\a\Makefile.venv\Makefile.venv\cache\cygwin system
Selected local directory: cache\cygwin-packages
##[error]Process completed with exit code -1073741571.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;At least some of those errors can be avoided by providing full absolute
paths to the installer and any argument values instead of relative
ones.&lt;/p&gt;
&lt;p&gt;In the end I've switched to Chocolatey to handle the installation for me.
It's certainly better but still requires calling &lt;code&gt;setup.exe&lt;/code&gt; to install
custom packages.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Since Cygwin installation and configuration are usually pretty slow (~3
    min), CI setup benefits a lot from caching this step between runs.
    Unfortunately, default GitHub actions for caching can't help with Cygwin
    root, because Windows is pretty hostile to an average Joe trying to make
    symlinks.&lt;/p&gt;
&lt;p&gt;Instead, I've added a separate step that calls &lt;code&gt;tar --dereference&lt;/code&gt;
explicitly and leaves only a simple archive for the caching action to
handle. Please note that tar uses exit code &lt;code&gt;1&lt;/code&gt; to indicate that
everything was OK, but some warnings were printed to stderr. Also, order
of command line arguments matters, at least for &lt;code&gt;--exclude&lt;/code&gt; values. That
was pretty unexpected for me.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You need to be careful when invoking apps under Cygwin - some environment
    variables may be inherited from &lt;code&gt;cmd&lt;/code&gt; session. For example, &lt;code&gt;$PATH&lt;/code&gt;
    will almost certainly point to binaries outside Cygwin root. I found that
    explicitly defining &lt;code&gt;$PATH&lt;/code&gt; simplifies matters a lot.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="powershellcmd-peculiarities"&gt;&lt;a class="toclink" href="#powershellcmd-peculiarities"&gt;PowerShell/cmd peculiarities&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Since host OS is still Windows, you get to encounter all the usual
PowerShell/cmd quirks. I tripped over the fact that PowerShell does not like
double-dashed --GNU-style options, and over weird nested quotes required to
properly combine environment variables and special characters in one value in
cmd.&lt;/p&gt;
&lt;h2 id="github-ci"&gt;&lt;a class="toclink" href="#github-ci"&gt;GitHub CI&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Some of my attempts were just me trying to work around GitHub CI limitations.
For example, dynamically calculating the value of environment variable based
on values of other variables. This looks quite ugly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;Use absolute path for CYGWIN_ROOT&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;run&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;echo &amp;quot;::set-env name=CYGWIN_ROOT::${env:GITHUB_WORKSPACE}\${env:CYGWIN_ROOT}&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I've also failed at proper syntax for YAML multiline strings more times than
I'm comfortable admitting :)&lt;/p&gt;</content><category term="posts"></category><category term="windows"></category><category term="cygwin"></category><category term="automation"></category><category term="ci"></category></entry></feed>