<!DOCTYPE html>
<html lang="en">
<head>
  <title>Don't blindly trust Docker for the selfhosted stuff</title>
  <meta name="description" content="Orange Sun | Posts | Vitaly Potyarkin | 2020-01-27">
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="referrer" content="origin">
  <meta name="generator" content="Pelican">
  <link href="https://potyarkin.ml/posts/2020/no-docker-for-selfhosted/" rel="canonical">
<link href="https://potyarkin.ml/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Orange Sun Full Atom Feed" />
<link href="https://potyarkin.ml/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="Orange Sun Full RSS Feed" />
  <link href="https://potyarkin.ml/theme/css/style.css?cache=ce1ce9e802f6452fc24c45dcd14f219b9fdbc4b78394fcb3ed490c23f88a6851" type="text/css" rel="stylesheet">
  <link href="https://potyarkin.ml/theme/css/fonts.css?cache=32c843bb3ce96eb9fb92f48c7a63dc133ab32e0d267a2e1453199c23403d5cd0" type="text/css" rel="stylesheet">
  <link href="https://potyarkin.ml/theme/css/codecolor/bleak.css?cache=4793611eaa86c9638927c57ac8d9995c5f7ca18d9ffed3721467cf3ef61b5e8e" type="text/css" rel="stylesheet">
    <link href="https://potyarkin.ml/static/custom.css?cache=e3963750b86fbc40a84ec4f04703361dd7c0b05acd171c3015a6d39c5477d664" type="text/css" rel="stylesheet">
  <style>
  :root {
    --accent-hue: 14.917127071823206;
    --accent-saturation: 87.43961352657004%;
    --accent-lightness: 59.411764705882355%;
    --accent-rgb: #f26a3d;
  }
  </style>
  <meta name="theme-color" content="#f26a3d">
</head>
<body class="pelican-article">
<nav id="menu">
  <a href="#" class="close button">Close</a>
  <a href="#menu" class="open button">Menu</a>
  <ul class="menu-list">
      <li><a href="/archive/">Archive</a></li>
      <li><a href="/tags/">Tags</a></li>
      <li><a href="mailto:sio.wtf@gmail.com">Email</a></li>
      <li><a href="https://github.com/sio">Github</a></li>
      <li><a href="/feeds/">feed</a></li>
      <li><a href="/bookmarks/">bookmarks</a></li>
      <li><a href="https://potyarkin.ml/blogroll/">Blogroll</a></li>
      <li><a href="https://potyarkin.ml/webring/">Webring</a></li>
  </ul>
</nav>  <header class="page-header">
    <h1>Don't blindly trust Docker for the selfhosted stuff</h1>
    <span class="subtitle"><a href="https://potyarkin.ml/">Orange Sun</a> |
<a href="https://potyarkin.ml/posts/">Posts</a> |   <a href="https://potyarkin.ml/">Vitaly Potyarkin</a>
| 2020-01-27
</span>
  </header>
<article class="full"><p>It is my strong belief that you shouldn't go crazy with <em>all-things-docker</em>
when deploying selfhosted services at home. Online forums, especially
<a href="https://reddit.com/r/selfhosted/">r/selfhosted</a>, seem to foster an opinion that providing a <code>Dockerfile</code> or
better yet a <code>docker-compose.yml</code> or even prebuilt public images on Docker Hub
is an acceptable way to distribute software targeting the selfhosting crowd.</p>
<p>I agree it is very convenient to deploy complex multipart services via these
tools. But the way many people appear to be doing that is a security
nightmare! This is how we get to encounter <a href="https://www.computerweekly.com/news/252437100/Heartbleed-and-WannaCry-thriving-in-Docker-community">Heartbleed in the
wild</a> four years after it should've been extinct.</p>
<p>There are <a href="https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/#protecting-cluster-components-from-compromise">many</a> comprehensive <a href="https://www.stackrox.com/post/2019/07/kubernetes-security-101/">writeups</a> on
Docker/Kubernetes security, I will highlight only a subset of problems below.</p>
<ul>
<li>
<p><strong>Shared libraries</strong></p>
<p>Running each service in its separate container results in having a
separate set of shared libraries for each one of those services. It is
convenient when you need to provide multiple incompatible dependencies at
once, but that way the burden of tracking the state of all those
dependencies lies on the user. Host OS can not tell you that one of the
containers still ships a vulnerable version of some critical library -
it's up to you to monitor and fix that.</p>
</li>
<li>
<p><strong>Container rebuilding</strong></p>
<p>Fixing anything related to the container requires rebuilding the image.
When you're using images from public registries you can not initiate image
rebuild even when you know it's needed. Your best option is to contact the
original uploader and to convince them to rebuild. That may take
significant time during which the containers running that image remain
vulnerable.</p>
</li>
<li>
<p><strong>Images from untrusted sources</strong></p>
<p>In addition to the points above you put enormous amount of trust into
people who provide the container you're running. In containerless scenario
you're required to trust the vendor who provides the base OS and the
developer who provides the custom applications you run upon that OS. When
containers come into play, you must extend your trust to the maintainer of
the container image, to the vendors who provide the base image that image
is built upon, to all the developers who provide any piece of code
included into that container. It does not even require malicious intent to
introduce a vulnerability into the resulting container, simple
incompetence of any of the parties involved may be just enough.</p>
</li>
</ul>
<p>This is why containerizing any workload comes with a significant extra cost of
designing and automating security maintenance procedures. It is easy to skip
this step when you're a hobbyist - but that's just burying your head in the
sand and waiting for some script kiddie or botnet to hijack your network.</p>
<p>Here is a rough overview of the required overhead:</p>
<ul>
<li>You need to run only containers that are based on the images you've built
  yourself. This is the only way you can ensure swift rebuilding in case one
  of the base images provides a security update. This step may include running
  your own image registry and build service.</li>
<li>You need to audit every Dockerfile you intend to build. This can only be
  done manually. And you need to check all the base images in the chain up to
  either a <code>FROM scratch</code> stanza or to a base image from trusted list.</li>
<li>You need to maintain a list of trusted base images that come from vendors
  with good reputation in regards to handling security issues.</li>
<li>You need to blacklist any image that does not come either from a trusted
  list or from a Dockerfile you've audited yourself.</li>
<li>You need to setup automated image rebuilds and container rollouts:
    a) on schedule
    b) on any update in the base image dependency chain</li>
<li>You need to setup automated vulnerability monitoring for the images you're
  running. This will require a lot more effort than subscribing to RSS feed of
  your distro security announcements - as it would've been the case with
  containerless deployment.</li>
</ul>
<p>Add that on top of usual container orchestration chores - and bare metal
suddenly becomes attractive. Docker and Kubernetes are great tools that solve
real world problems but using them in a secure manner requires continuous
dedicated effort. For enterprise deployments the benefits of containerization
usually outweigh the extra maintenance cost, but for hobbyist use I'm not so
sure.</p></article>
<nav class="article-tags">
  <a href="https://potyarkin.ml/tags/docker/">docker</a>
  <a href="https://potyarkin.ml/tags/kubernetes/">kubernetes</a>
  <a href="https://potyarkin.ml/tags/automation/">automation</a>
</nav>
<nav class="neighbors">
  <a class="neighbor neighbor-prev" href="https://potyarkin.ml/posts/2019/manage-python-virtual-environment-from-your-makefile/">
    <h1>Manage Python virtual environment from your Makefile</h1>
    <p>I often use Makefiles not just as a build tool but as a handy way to execute sequences...</p>
  </a>
  <a class="neighbor neighbor-next" href="https://potyarkin.ml/posts/2020/cygwin-ci-journey/">
    <h1>Cygwin CI journey</h1>
    <p>Setting up Cygwin CI environment for testing one of my projects took more than fifty...</p>
  </a>
</nav>
<footer class="page-footer">
  <section class="credits">
        <span class="credits-left">
          Published with <a href="https://github.com/getpelican/pelican" rel="nofollow">Pelican</a>
        </span>
        <span class="credits-center">
          <a href="https://potyarkin.ml/">Orange Sun</a>
        </span>
        <span class="credits-right">
          Theme <a href="https://github.com/sio/pelican-smallweb" rel="nofollow">SmallWeb</a>
        </span>
  </section>
</footer></body>
</html>